# T094: Automated Deployment Workflow
# Multi-Tenant SaaS Platform - CI/CD Pipeline for AWS Deployment

name: Deploy to AWS

on:
  push:
    branches:
      - main
      - staging
  pull_request:
    branches:
      - main
      - staging
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy'
        required: true
        default: 'dev'
        type: choice
        options:
          - dev
          - staging
          - prod

env:
  AWS_REGION: us-east-1
  TERRAFORM_VERSION: 1.5.0
  JAVA_VERSION: '21'
  NODE_VERSION: '18'

jobs:
  ##############################################################################
  # Backend Build and Test
  ##############################################################################
  backend-build:
    name: Build and Test Backend
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up JDK 21
        uses: actions/setup-java@v4
        with:
          java-version: ${{ env.JAVA_VERSION }}
          distribution: 'temurin'
          cache: 'maven'

      - name: Run backend tests
        working-directory: ./backend
        run: mvn clean test

      - name: Generate coverage report
        working-directory: ./backend
        run: mvn jacoco:report

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          files: ./backend/target/site/jacoco/jacoco.xml
          flags: backend
          fail_ci_if_error: false

      - name: Build backend JAR
        working-directory: ./backend
        run: mvn clean package -DskipTests

      - name: Upload backend artifact
        uses: actions/upload-artifact@v4
        with:
          name: backend-jar
          path: backend/target/*.jar
          retention-days: 7

  ##############################################################################
  # Frontend Build and Test
  ##############################################################################
  frontend-build:
    name: Build and Test Frontend
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install frontend dependencies
        working-directory: ./frontend
        run: npm ci

      - name: Run frontend tests
        working-directory: ./frontend
        run: npm test -- --coverage --watchAll=false

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v4
        with:
          files: ./frontend/coverage/lcov.info
          flags: frontend
          fail_ci_if_error: false

      - name: Build frontend
        working-directory: ./frontend
        env:
          VITE_API_BASE_URL: ${{ secrets.API_BASE_URL }}
          VITE_COGNITO_USER_POOL_ID: ${{ secrets.COGNITO_USER_POOL_ID }}
          VITE_COGNITO_CLIENT_ID: ${{ secrets.COGNITO_CLIENT_ID }}
        run: npm run build

      - name: Upload frontend artifact
        uses: actions/upload-artifact@v4
        with:
          name: frontend-dist
          path: frontend/dist
          retention-days: 7

  ##############################################################################
  # Terraform Validation
  ##############################################################################
  terraform-validate:
    name: Validate Terraform
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Terraform Format Check
        working-directory: ./infrastructure/terraform
        run: terraform fmt -check -recursive

      - name: Terraform Init
        working-directory: ./infrastructure/terraform
        run: terraform init -backend=false

      - name: Terraform Validate
        working-directory: ./infrastructure/terraform
        run: terraform validate

  ##############################################################################
  # Build and Push Docker Images
  ##############################################################################
  docker-build-push:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: [backend-build, frontend-build, terraform-validate]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/staging'

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Set environment from branch
        id: set-env
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "ENV=prod" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "ENV=staging" >> $GITHUB_OUTPUT
          else
            echo "ENV=dev" >> $GITHUB_OUTPUT
          fi

      - name: Build and push backend image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: saas-platform-backend
          IMAGE_TAG: ${{ github.sha }}
          ENVIRONMENT: ${{ steps.set-env.outputs.ENV }}
        working-directory: ./backend
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:$ENVIRONMENT-latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$ENVIRONMENT-latest

      - name: Build and push frontend image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          ECR_REPOSITORY: saas-platform-frontend
          IMAGE_TAG: ${{ github.sha }}
          ENVIRONMENT: ${{ steps.set-env.outputs.ENV }}
        working-directory: ./frontend
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker tag $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG $ECR_REGISTRY/$ECR_REPOSITORY:$ENVIRONMENT-latest
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$ENVIRONMENT-latest

  ##############################################################################
  # Deploy Infrastructure with Terraform
  ##############################################################################
  terraform-deploy:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    needs: [docker-build-push]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/staging'

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: ${{ env.TERRAFORM_VERSION }}

      - name: Set environment from branch
        id: set-env
        run: |
          if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
            echo "ENV=prod" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref }}" == "refs/heads/staging" ]]; then
            echo "ENV=staging" >> $GITHUB_OUTPUT
          else
            echo "ENV=dev" >> $GITHUB_OUTPUT
          fi

      - name: Terraform Init
        working-directory: ./infrastructure/terraform
        run: |
          terraform init \
            -backend-config="bucket=${{ secrets.TF_STATE_BUCKET }}" \
            -backend-config="key=${{ steps.set-env.outputs.ENV }}/terraform.tfstate" \
            -backend-config="region=${{ env.AWS_REGION }}"

      - name: Terraform Plan
        working-directory: ./infrastructure/terraform
        env:
          TF_VAR_environment: ${{ steps.set-env.outputs.ENV }}
          TF_VAR_backend_image_tag: ${{ github.sha }}
          TF_VAR_db_password: ${{ secrets.DB_PASSWORD }}
          TF_VAR_internal_api_secret: ${{ secrets.INTERNAL_API_SECRET }}
          TF_VAR_google_client_id: ${{ secrets.GOOGLE_CLIENT_ID }}
          TF_VAR_google_client_secret: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          TF_VAR_github_client_id: ${{ secrets.GITHUB_CLIENT_ID }}
          TF_VAR_github_client_secret: ${{ secrets.GITHUB_CLIENT_SECRET }}
        run: terraform plan -out=tfplan

      - name: Terraform Apply
        working-directory: ./infrastructure/terraform
        if: github.event_name != 'pull_request'
        run: terraform apply -auto-approve tfplan

      - name: Get Terraform Outputs
        id: terraform-outputs
        working-directory: ./infrastructure/terraform
        run: |
          echo "cloudfront_distribution_id=$(terraform output -raw cloudfront_distribution_id)" >> $GITHUB_OUTPUT
          echo "frontend_s3_bucket=$(terraform output -raw frontend_s3_bucket)" >> $GITHUB_OUTPUT
          echo "backend_api_url=$(terraform output -raw backend_api_url)" >> $GITHUB_OUTPUT
          echo "ecs_cluster_name=$(terraform output -raw ecs_cluster_name)" >> $GITHUB_OUTPUT
          echo "ecs_service_name=$(terraform output -raw ecs_service_name)" >> $GITHUB_OUTPUT

    outputs:
      cloudfront_distribution_id: ${{ steps.terraform-outputs.outputs.cloudfront_distribution_id }}
      frontend_s3_bucket: ${{ steps.terraform-outputs.outputs.frontend_s3_bucket }}
      backend_api_url: ${{ steps.terraform-outputs.outputs.backend_api_url }}
      ecs_cluster_name: ${{ steps.terraform-outputs.outputs.ecs_cluster_name }}
      ecs_service_name: ${{ steps.terraform-outputs.outputs.ecs_service_name }}

  ##############################################################################
  # Deploy Frontend to S3 and Invalidate CloudFront
  ##############################################################################
  deploy-frontend:
    name: Deploy Frontend
    runs-on: ubuntu-latest
    needs: [terraform-deploy]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/staging'

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Download frontend artifact
        uses: actions/download-artifact@v4
        with:
          name: frontend-dist
          path: frontend/dist

      - name: Deploy to S3
        run: |
          aws s3 sync frontend/dist/ s3://${{ needs.terraform-deploy.outputs.frontend_s3_bucket }}/ \
            --delete \
            --cache-control "public,max-age=31536000,immutable" \
            --exclude "index.html"

          aws s3 cp frontend/dist/index.html s3://${{ needs.terraform-deploy.outputs.frontend_s3_bucket }}/index.html \
            --cache-control "no-cache,no-store,must-revalidate"

      - name: Invalidate CloudFront cache
        run: |
          aws cloudfront create-invalidation \
            --distribution-id ${{ needs.terraform-deploy.outputs.cloudfront_distribution_id }} \
            --paths "/*"

  ##############################################################################
  # Update ECS Service
  ##############################################################################
  deploy-backend:
    name: Deploy Backend
    runs-on: ubuntu-latest
    needs: [terraform-deploy]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/staging'

    permissions:
      id-token: write
      contents: read

    steps:
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_DEPLOY_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Force ECS service update
        run: |
          aws ecs update-service \
            --cluster ${{ needs.terraform-deploy.outputs.ecs_cluster_name }} \
            --service ${{ needs.terraform-deploy.outputs.ecs_service_name }} \
            --force-new-deployment

      - name: Wait for service stability
        run: |
          aws ecs wait services-stable \
            --cluster ${{ needs.terraform-deploy.outputs.ecs_cluster_name }} \
            --services ${{ needs.terraform-deploy.outputs.ecs_service_name }}

  ##############################################################################
  # Smoke Tests
  ##############################################################################
  smoke-tests:
    name: Run Smoke Tests
    runs-on: ubuntu-latest
    needs: [deploy-frontend, deploy-backend]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/staging'

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Wait for deployment
        run: sleep 30

      - name: Test backend health
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" ${{ needs.terraform-deploy.outputs.backend_api_url }}/actuator/health)
          if [ $response -ne 200 ]; then
            echo "Backend health check failed with status $response"
            exit 1
          fi
          echo "Backend health check passed"

      - name: Test frontend availability
        env:
          FRONTEND_URL: ${{ secrets.FRONTEND_URL }}
        run: |
          response=$(curl -s -o /dev/null -w "%{http_code}" $FRONTEND_URL)
          if [ $response -ne 200 ]; then
            echo "Frontend health check failed with status $response"
            exit 1
          fi
          echo "Frontend health check passed"

      - name: Send deployment notification
        if: always()
        run: |
          echo "Deployment completed with status: ${{ job.status }}"
          # Add Slack/email notification here if needed
